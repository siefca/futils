

<!DOCTYPE html>
<html >
  <head>
    <meta charset="UTF-8">
    <meta name="google" value="notranslate">
    <link rel="icon" type="image/png" href="img/favicon.png" />

    <title>futils</title>

    
  <link href='http://fonts.googleapis.com/css?family=Raleway:300' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">

  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/clojure.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/magula.min.css">

  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.2/angular.min.js"></script>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular-cookies.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/angular-ui-bootstrap/0.13.0/ui-bootstrap-tpls.min.js"></script>
  <script type="text/javascript" src="js/angular-highlightjs.min.js"></script>

  <link rel="stylesheet" type="text/css" href="css/rdash.min.css">
  <link rel="stylesheet" type="text/css" href="css/scrollspy.css">


  <script>
    window.console = window.console || function(t) {};
    window.open = function(){ console.log("window.open is disabled."); };
    window.print   = function(){ console.log("window.print is disabled."); };
  </script>

  <script>
    var app = angular.module('app', ['hljs']);
  </script>
  </head>

  <body ng-app="app" data-spy="scroll" data-target=".scrollspy">
  <!-- Fixed navbar -->
    <nav class="navbar navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html"><img src="img/logo-white.png"></a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
              <a href="https://github.com/siefca/futils" target="_blank">Github</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>


  <div class="container row">
    <div class="col-md-4 scrollspy pull-right">
      <ul id="nav" class="nav hidden-xs hidden-sm" data-spy="affix">
        <li><a href="#introduction">1  &nbsp;&nbsp; Introduction</a></li><li><a href="#installation">2  &nbsp;&nbsp; Installation</a></li><li><a href="#usage">3  &nbsp;&nbsp; Usage</a><ul class="nav"><li><a href="#argc">3.1  &nbsp;&nbsp; argc</a></li><li><a href="#relax">3.2  &nbsp;&nbsp; relax</a></li><li><a href="#relax*">3.3  &nbsp;&nbsp; relax*</a></li><li><a href="#nameize">3.4  &nbsp;&nbsp; nameize</a></li><li><a href="#nameize*">3.5  &nbsp;&nbsp; nameize*</a></li><li><a href="#frepeat">3.6  &nbsp;&nbsp; frepeat</a></li><li><a href="#mapply">3.7  &nbsp;&nbsp; mapply</a></li></ul></li>
      </ul>
    </div>
    <div class="col-md-8" id="content">
      <div class="jumbotron">
        <div class="container">
          <h1>futils</h1>
          <h4>Function Utilities Library</h4>
        </div>
      </div>
      <section class="chapter" id="introduction"><h2 class="chapter">1  &nbsp;&nbsp; Introduction</h2><div class="group"><div class="paragraph"><p><code>futils</code> is a library that provides a set of forms that add some abstractions for managing functions in Clojure.</p><p>Currently provided macros and functions are:</p><ul><li><a href='#argc'><code>futils.args/argc</code></a> – counts arguments a function takes (for all arities),</li><li><a href='#relax'><code>futils.args/relax</code></a> – wraps a function in a way that it accepts any number of  arguments,</li><li><a href='#relax&#42;'><code>futils.args/relax&#42;</code></a> – like <code>relax</code> but it requires to explicitly  describe the accepted arities,</li><li><a href='#nameize'><code>futils.named/nameize</code></a> – transforms a function so it accepts named arguments,</li><li><a href='#nameize&#42;'><code>futils.named/nameize&#42;</code></a> – like <code>nameize</code> but requires symbols to be quoted,</li><li><a href='#frepeat'><code>futils.utils/frepeat</code></a> – creates a sequence of returned values (uses named arguments),</li><li><a href='#mapply'><code>futils.utlis/mapply</code></a> – works like apply but with named arguments.</li></ul></div></div></section><section class="chapter" id="installation"><h2 class="chapter">2  &nbsp;&nbsp; Installation</h2><div class="group"><div class="paragraph"><p>Add to <code>project.clj</code> dependencies:</p><p><code>&#91;pl.randomseed/futils </code>"<code>0.7.0</code>"<code>&#93;</code></p><p>Then require it in your program:</p><p><code>&#40;require 'futils.utils :as futils&#41;</code><br /> <code>&#40;require 'futils.args  :as fargs&#41;</code><br /> <code>&#40;require 'futils.named :as fnamed&#41;</code><br /></p><p>(depending on which functions should be used) or:</p><p><code>&#40;ns your-namespace</code><br /> <code>  &#40;:require &#91;futils.utils :as futils&#93;&#41;</code><br /> <code>  &#40;:require &#91;futils.args  :as fargs&#93;&#41;</code><br /> <code>  &#40;:require &#91;futils.named :as fnamed&#93;&#41;&#41;</code></p></div></div></section><section class="chapter" id="usage"><h2 class="chapter">3  &nbsp;&nbsp; Usage</h2><section class="section" id="argc"><h3 class="section">3.1  &nbsp;&nbsp; argc</h3><div class="code"><a name="argc-synopsis"></a><div hljs="hljs" language="clojure" no-escape="no-escape">(futils.args/argc f &amp; options)</div></div><div class="paragraph"><p>Determines the number of arguments that the given function takes and returns a map containing these keys:</p><ul><li><code>:arities</code>  – a sorted set of argument counts for all arities,</li><li><code>:engine</code>:<ul><li><code>:clj</code> – if metadata were used to determine arities – DEPRECATED);</li><li><code>:jvm</code> – if Java reflection methods were used to determine arities),</li></ul></li><li><code>:macro</code>    – a flag informing whether the given object is a macro,</li><li><code>:variadic</code> – a flag informing whether the widest arity is variadic.</li></ul><p>Variadic parameter is counted as one of the possible arguments.</p><p>The macro flag (<code>:macro</code>) is only present when macro was detected.</p><p>If the given argument cannot be used to obtain a Var bound to a functon or a function object then it returns <code>nil</code>.</p></div><section class="subsection" id="argc-usage-ex"><h4 class="subsection">3.1.1  &nbsp;&nbsp; Usage examples</h4><div class="code"><a name="argc-usage"></a><h5>e.3.1  &nbsp;-&nbsp; Using <code>argc</code> on anonymous functions</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(argc (fn ([x y]) ([])))
=&gt; {:arities  #{0 2}
    :engine   :jvm
    :variadic false}
  
(argc (fn [a b &amp; c]))
=&gt; {:arities  #{3}
    :engine   :jvm
    :variadic true}</div></div><div class="code"><a name="argc-usage-named"></a><h5>e.3.2  &nbsp;-&nbsp; Using <code>argc</code> on named functions</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun ([]) ([a]) ([a b]) ([a b &amp; c]))
  
(argc fun)
=&gt; {:arities  #{0 1 2 3}
    :engine   :jvm
    :variadic true}</div></div><div class="code"><a name="argc-usage-macro"></a><h5>e.3.3  &nbsp;-&nbsp; Using <code>argc</code> on macros</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defmacro mak ([]) ([a]) ([a b]) ([a b &amp; c]))
  
(argc #'mak)
=&gt; {:arities  #{0 1 2 3}
    :engine   :jvm
    :macro    true
    :variadic true}</div></div><div class="code"><a name="argc-usage-macro-2"></a><h5>e.3.4  &nbsp;-&nbsp; Using <code>argc</code> on macros (by symbols)</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defmacro mak ([]) ([a]))
  
(argc mak)
=&gt; {:arities  #{0 1}
    :engine   :jvm
    :macro    true
    :variadic false}</div></div><div class="code"><a name="argc-usage-notfun"></a><h5>e.3.5  &nbsp;-&nbsp; Handling invalid values by <code>argc</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def notfun)
  
(argc   1)    =&gt; nil
(argc nil)    =&gt; nil
(argc &quot;a&quot;)    =&gt; nil
(argc notfun) =&gt; nil
(argc String) =&gt; nil</div></div></section></section><section class="section" id="relax"><h3 class="section">3.2  &nbsp;&nbsp; relax</h3><div class="code"><a name="relax-synopsis"></a><div hljs="hljs" language="clojure" no-escape="no-escape">(futils.args/relax f &amp; options)</div></div><div class="paragraph"><p>Returns a variadic function object that calls the given function <code>f</code>, adjusting the number of passed arguments to nearest matching arity. It cuts argument list or pads it with <code>nil</code> values if necessary.</p><p>The arities will be obtained from metadata (if the given object is a symbol bound to a <code>Var</code> or a <code>Var</code> object itself) or using JVM reflection calls to anonymous class representing a function object (in case of function object).</p><p>To determine the number of arguments the nearest arity is picked up by matching a number of passed arguments to number of arguments for each arity. If there is no exact match then the next arity capable of taking all arguments is selected.</p><p>If the expected number of arguments is lower than a number of arguments actually passed to a wrapper call, the exceeding ones will be ignored.</p><p>If the declared number of arguments that the original function expects is higher than a number of arguments really passed then <code>nil</code> values will be placed as extra arguments.</p><p>When a variadic function is detected and its variadic arity is the closest to a number of arguments passed then all of them will be used during a function call (no argument will be ignored).</p><p>It takes optional named arguments:</p><ul><li><code>:pad-fn</code> – a function that generates values for padding,</li><li><code>:pad-val</code> – a value to use for padding instead of <code>nil</code>,</li><li><code>:verbose</code> – a switch (defaults to <code>false</code>) that if set to true causes               wrapper to return a map containing additional information.</li></ul><p>See <a href='#relax&#42;'><code>relax&#42;</code></a> for detailed descriptions of <code>:pad-fn</code> and <code>:verbose</code> options.</p></div><section class="subsection" id="relax-usage-ex"><h4 class="subsection">3.2.1  &nbsp;&nbsp; Usage examples</h4><div class="code"><a name="relax-usage"></a><h5>e.3.6  &nbsp;-&nbsp; Using <code>relax</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun
  ([a b]   (list a b))
  ([a b c] (list a b c)))
  
(def relaxed (relax fun))
  
(relaxed)         =&gt; '(nil nil)
(relaxed 1)       =&gt; '(1 nil)
(relaxed 1 2)     =&gt; '(1 2)
(relaxed 1 2 3)   =&gt; '(1 2 3)
(relaxed 1 2 3 4) =&gt; '(1 2 3)
  
(def relaxed (relax #'fun))
  
(relaxed)         =&gt; '(nil nil)
(relaxed 1 2 3 4) =&gt; '(1 2 3)</div></div><div class="code"><a name="relax-usage-variadic"></a><h5>e.3.7  &nbsp;-&nbsp; Handling variadic arguments by <code>relax</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun
  ([a] (list a))
  ([a b &amp; more] (list* a b more)))
  
(def relaxed (relax fun))
  
(relaxed)         =&gt; '(nil)      ; matched arity: [a]
(relaxed 1)       =&gt; '(1)        ; matched arity: [a]
(relaxed 1 2)     =&gt; '(1 2)      ; matched arity: [a b &amp; more]
(relaxed 1 2 3)   =&gt; '(1 2 3)    ; matched arity: [a b &amp; more]
(relaxed 1 2 3 4) =&gt; '(1 2 3 4)  ; matched arity: [a b &amp; more]
  
(defn fun2 [&amp; more] more)
(def relaxed (relax fun2))
  
(relaxed)         =&gt; nil
(relaxed 1)       =&gt; '(1)
(relaxed 1 2)     =&gt; '(1 2)
(relaxed 1 2 3)   =&gt; '(1 2 3)
(relaxed 1 2 3 4) =&gt; '(1 2 3 4)</div></div><div class="code"><a name="relax-usage-anonymous"></a><h5>e.3.8  &nbsp;-&nbsp; Using <code>relax</code> on anonymous functions</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def relaxed
  (relax (fn
           ([a]     (list a))
           ([a b c] (list a b c)))))
  
(relaxed)         =&gt; '(nil)      ; matched arity: [a]
(relaxed 1)       =&gt; '(1)        ; matched arity: [a]
(relaxed 1 2)     =&gt; '(1 2 nil)  ; matched arity: [a b c]
(relaxed 1 2 3)   =&gt; '(1 2 3)    ; matched arity: [a b c]
(relaxed 1 2 3 4) =&gt; '(1 2 3)    ; matched arity: [a b c]</div></div><div class="code"><a name="relax-usage-padding-val"></a><h5>e.3.9  &nbsp;-&nbsp; Custom padding value</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def relaxed (relax #(list %1 %2 %3) :pad-val :nic))
  
(relaxed)           =&gt; '(:nic :nic :nic)
(relaxed 1)         =&gt; '(1 :nic :nic)
(relaxed 1 2)       =&gt; '(1 2 :nic)
(relaxed 1 2 3)     =&gt; '(1 2 3)
(relaxed 1 2 3 4)   =&gt; '(1 2 3)</div></div><div class="code"><a name="relax-usage-padding-fn"></a><h5>e.3.10  &nbsp;-&nbsp; Custom padding function</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn padder
  [&amp; {:keys [previous] :or {previous -1}}]
  (inc previous))
  
(def relaxed (relax #(list %1 %2 %3) :pad-fn padder))
  
(relaxed)         =&gt; '(0 1 2)
(relaxed 1)       =&gt; '(1 2 3)
(relaxed 5)       =&gt; '(5 6 7)
(relaxed 1 8)     =&gt; '(1 8 9)</div></div><div class="code"><a name="relax-usage-verbose"></a><h5>e.3.11  &nbsp;-&nbsp; Verbose mode</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun
  ([a] (list a))
  ([a b &amp; more] (list* a b more)))
  
(def relaxed (relax fun :verbose true))
  
(relaxed)
=&gt; {:argc-cutted   0
    :argc-padded   1
    :argc-received 0
    :argc-sent     1
    :args-received ()
    :args-sent     '(nil)
    :arities       #{1 3}
    :arity-matched 1
    :engine        :jvm
    :result        '(nil)
    :variadic      true
    :variadic-used false
    :verbose       true} 
  
(relaxed 1 2 3)
=&gt; {:argc-cutted   0
    :argc-padded   0
    :argc-received 3
    :argc-sent     3
    :args-received '(1 2 3)
    :args-sent     '(1 2 3)
    :arities       #{1 3}
    :arity-matched 3
    :engine        :jvm
    :result        '(1 2 3)
    :variadic      true
    :variadic-used true
    :verbose       true}</div></div><div class="code"><a name="relax-usage-notfun"></a><h5>e.3.12  &nbsp;-&nbsp; Handling invalid values</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def notfun)
  
(relax   1)    =&gt; (throws java.lang.AssertionError)
(relax nil)    =&gt; (throws java.lang.AssertionError)
(relax &quot;a&quot;)    =&gt; (throws java.lang.AssertionError)
(relax notfun) =&gt; (throws java.lang.AssertionError)
(relax String) =&gt; (throws java.lang.AssertionError)</div></div></section></section><section class="section" id="relax*"><h3 class="section">3.3  &nbsp;&nbsp; relax*</h3><div class="code"><a name="relax*-synopsis"></a><div hljs="hljs" language="clojure" no-escape="no-escape">(futils.args/relax* f &amp; options)</div></div><div class="paragraph"><p>Returns a variadic function object that calls the given function, adjusting the number of passed arguments to nearest matching arity. It cuts argument list or pads it with nil values if necessary.</p><p>It takes 1 positional, obligatory argument, which should be a function (<code>f</code>) and two named, keyword arguments:</p><ul><li><code>:arities</code> – a sorted set of argument counts for all arities,</li><li><code>:variadic</code> – a flag informing whether the widest arity is variadic.</li></ul><p>It also makes use of optional named arguments:</p><ul><li><code>:pad-fn</code>  – a function that generates values for padding,</li><li><code>:pad-val</code> – a value to use for padding instead of <code>nil</code>,</li><li><code>:verbose</code> – a switch (defaults to <code>false</code>) that if set to <code>true</code>, causes wrapper               to return a map containing additional information.</li></ul><p>To determine the number of arguments the nearest arity is picked up by matching a number of passed arguments to each number from a set (passed as <code>:arities</code> keyword argument). If there is no exact match then the next arity capable of handling all arguments is selected.</p><p>If the expected number of arguments is lower than a number of arguments actually passed to a wrapper call, the exceeding ones will be ignored.</p><p>If the declared number of arguments that the original function expects is higher than a number of arguments really passed then nil values will be placed as extra arguments.</p><p>When a variadic function is detected and its variadic arity is the closest to a number of arguments passed then all of them will be used to call a function.</p></div><section class="subsection" id="relax*-verbose-mode"><h4 class="subsection">3.3.1  &nbsp;&nbsp; Verbose mode</h4><div class="paragraph"><p>If the <code>:verbose</code> flag is set the result will be a map containing the following:</p><ul><li><code>:argc-received</code> – a number of arguments received by the wrapper,</li><li><code>:argc-sent</code>     – a number of arguments passed to a function,</li><li><code>:argc-cutted</code>   – a number of arguments ignored,</li><li><code>:argc-padded</code>   – a number of arguments padded with <code>nil</code> values,</li><li><code>:args-received</code> – arguments received by the wrapper,</li><li><code>:args-sent</code>     – arguments passed to a function,</li><li><code>:arities</code>       – a sorted set of argument counts for all arities,</li><li><code>:arity-matched</code> – an arity (as a number of arguments) that matched,</li><li><code>:engine</code>        – a method used to check arities (<code>:clj</code> or <code>:jvm</code>),</li><li><code>:result</code>        – a result of calling the original function,</li><li><code>:variadic</code>      – a flag telling that the widest arity is variadic,</li><li><code>:variadic-used</code> – a flag telling that a variadic arity was used,</li><li><code>:verbose</code>       – a verbosity flag (always <code>true</code> in this case).</li></ul></div></section><section class="subsection" id="relax*-pad-fn"><h4 class="subsection">3.3.2  &nbsp;&nbsp; Padding function</h4><div class="paragraph"><p>If a padding function is given (with <code>:pad-fn</code>) it should take keyword arguments. During each call the following keys will be set:</p><ul><li><code>:argc-received</code> – a number of arguments received by the wrapper,</li><li><code>:arity-matched</code> – an arity (as a number of arguments) that matched,</li><li><code>:iteration</code>     – a number of current iteration (starting from 1),</li><li><code>:iterations</code>    – a total number of iterations,</li><li><code>:previous</code>      – a value of previously calculated argument (the result  of a previous call or a value of the last positional argument when padding  function is called for the first time).</li></ul><p>Values associated with <code>:iteration</code> and <code>:previous</code> keys will change during each call, the rest will remain constant.</p><p>If there is no last argument processed at a time when <code>f</code> is called for the first time (because no arguments were passed), the :previous key is not added to a passed map. That allows to use a default value in a binding map of <code>f</code> or to make easy checks if there would be some previous value (<code>nil</code> is ambiguous).</p></div></section><section class="subsection" id="relax*-usage-ex"><h4 class="subsection">3.3.3  &nbsp;&nbsp; Usage examples</h4><div class="code"><a name="relax*-usage"></a><h5>e.3.13  &nbsp;-&nbsp; Using <code>relax*</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun
  ([a b]   (list a b))
  ([a b c] (list a b c)))
  
(def relaxed (relax* fun :arities #{2 3}))
  
(relaxed)         =&gt; '(nil nil)
(relaxed 1)       =&gt; '(1 nil)
(relaxed 1 2)     =&gt; '(1 2)
(relaxed 1 2 3)   =&gt; '(1 2 3)
(relaxed 1 2 3 4) =&gt; '(1 2 3)</div></div><div class="code"><a name="relax*-usage-variadic"></a><h5>e.3.14  &nbsp;-&nbsp; Handling variadic arguments by <code>relax*</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun
  ([a] (list a))
  ([a b &amp; more] (list* a b more)))
  
(def relaxed (relax* fun
                     :arities #{3 1}
                     :variadic true))
  
(relaxed)         =&gt; '(nil)      ; matched arity: [a]
(relaxed 1)       =&gt; '(1)        ; matched arity: [a]
(relaxed 1 2 3 4) =&gt; '(1 2 3 4)  ; matched arity: [a b &amp; more]
  
(defn fun2 [&amp; more] more)
(def relaxed (relax* fun2 :arities #{1} :variadic true))
  
(relaxed)         =&gt; nil
(relaxed 1)       =&gt; '(1)
(relaxed 1 2 3 4) =&gt; '(1 2 3 4)</div></div><div class="code"><a name="relax*-usage-anonymous"></a><h5>e.3.15  &nbsp;-&nbsp; Using <code>relax*</code> on anonymous functions</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def relaxed
  (relax* (fn
            ([a]     (list a))
            ([a b c] (list a b c)))
          :arities #{3 1}))
  
(relaxed)         =&gt; '(nil)      ; matched arity: [a]
(relaxed 1)       =&gt; '(1)        ; matched arity: [a]
(relaxed 1 2)     =&gt; '(1 2 nil)  ; matched arity: [a b c]
(relaxed 1 2 3 4) =&gt; '(1 2 3)</div></div><div class="code"><a name="relax*-usage-padding-val"></a><h5>e.3.16  &nbsp;-&nbsp; Custom padding value</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def relaxed (relax* #(list %1 %2 %3)
                     :arities #{3}
                     :pad-val :nic))
  
(relaxed)           =&gt; '(:nic :nic :nic)
(relaxed 1)         =&gt; '(1 :nic :nic)
(relaxed 1 2 3 4)   =&gt; '(1 2 3)</div></div><div class="code"><a name="relax*-usage-padding-fn"></a><h5>e.3.17  &nbsp;-&nbsp; Custom padding function</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn padder
  [&amp; {:keys [previous] :or {previous -1}}]
  (inc previous))
  
(def relaxed (relax* #(list %1 %2 %3)
                     :arities #{3}
                     :pad-fn padder))
  
(relaxed)         =&gt; '(0 1 2)
(relaxed 1)       =&gt; '(1 2 3)
(relaxed 5)       =&gt; '(5 6 7)
(relaxed 1 8)     =&gt; '(1 8 9)</div></div><div class="code"><a name="relax*-usage-verbose"></a><h5>e.3.18  &nbsp;-&nbsp; Verbose mode</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun
  ([a] (list a))
  ([a b &amp; more] (list* a b more)))
  
(def relaxed (relax* fun
                     :arities #{3 1}
                     :variadic true
                     :verbose true))
  
(relaxed)
=&gt; {:argc-cutted   0
    :argc-padded   1
    :argc-received 0
    :argc-sent     1
    :args-received ()
    :args-sent     '(nil)
    :arities       #{1 3}
    :arity-matched 1
    :result        '(nil)
    :variadic      true
    :variadic-used false
    :verbose       true} 
  
(relaxed 1 2 3)
=&gt; {:argc-cutted   0
    :argc-padded   0
    :argc-received 3
    :argc-sent     3
    :args-received '(1 2 3)
    :args-sent     '(1 2 3)
    :arities       #{1 3}
    :arity-matched 3
    :result        '(1 2 3)
    :variadic      true
    :variadic-used true
    :verbose       true}</div></div><div class="code"><a name="relax*-usage-argc"></a><h5>e.3.19  &nbsp;-&nbsp; Chaining with <code>argc</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun
  ([a b]   (list a b))
  ([a b c] (list a b c)))
  
(def relaxed (mapply relax* fun (argc fun)))
  
(relaxed)         =&gt; '(nil nil)
(relaxed 1)       =&gt; '(1 nil)
(relaxed 1 2)     =&gt; '(1 2)
(relaxed 1 2 3)   =&gt; '(1 2 3)
(relaxed 1 2 3 4) =&gt; '(1 2 3)</div></div><div class="code"><a name="relax*-usage-power"></a><h5>e.3.20  &nbsp;-&nbsp; With great power comes great responsibility</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun
  ([a b]   (list a b))
  ([a b c] (list a b c)))
  
(def relaxed (relax* fun :arities #{1 2 5}))  ; wrong arities!
  
(relaxed)         =&gt; (throws clojure.lang.ArityException)
(relaxed 1)       =&gt; (throws clojure.lang.ArityException)
(relaxed 1 2)     =&gt; '(1 2)
(relaxed 1 2 3)   =&gt; (throws clojure.lang.ArityException)
(relaxed 1 2 3 4) =&gt; (throws clojure.lang.ArityException)</div></div><div class="code"><a name="relax*-usage-notfun"></a><h5>e.3.21  &nbsp;-&nbsp; Handling invalid values</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn fun [])
(def  notfun)
  
(relax*    #())               =&gt; (throws java.lang.AssertionError)
(relax*    #() #())           =&gt; (throws java.lang.IllegalArgumentException)
(relax*    nil nil)           =&gt; (throws java.lang.IllegalArgumentException)
(relax*    :arities #{0} #()) =&gt; (throws java.lang.AssertionError)
(relax*    #() :arities #{})  =&gt; (throws java.lang.AssertionError)
(relax*    #() :arities nil)  =&gt; (throws java.lang.AssertionError)
(relax*    #() :arities 123)  =&gt; (throws java.lang.IllegalArgumentException)
(relax*      1 :arities #{})  =&gt; (throws java.lang.AssertionError)
(relax*      1 :arities #{})  =&gt; (throws java.lang.AssertionError)
(relax*    nil :arities #{0}) =&gt; (throws java.lang.AssertionError)
(relax*    &quot;a&quot; :arities #{0}) =&gt; (throws java.lang.AssertionError)
(relax* notfun :arities #{0}) =&gt; (throws java.lang.AssertionError)
(relax* String :arities #{0}) =&gt; (throws java.lang.AssertionError)
(relax*  #'fun :arities #{0}) =&gt; (throws java.lang.AssertionError)</div></div></section></section><section class="section" id="nameize"><h3 class="section">3.4  &nbsp;&nbsp; nameize</h3><div class="code"><a name="nameize-synopsis"></a><div hljs="hljs" language="clojure" no-escape="no-escape">(futils.named/nameize f [names])
(futils.named/nameize f [names] {defaults})
(futils.named/nameize f arity-mappings…)</div></div><div class="paragraph"><p>where <code>arity-mappings</code> is a pair expressed as: <code>&#91;names&#93; {defaults}</code>.</p></div><div class="paragraph"><p>Creates a wrapper that passes named arguments as positional arguments. Takes a funtion object (<code>f</code>), a vector S-expression containing names of expected arguments (<code>names</code>) expressed as keywords, symbols, strings or whatever suits you, and an optional map S-expression of default values for named arguments (<code>defaults</code>).</p><p>Since version 0.7.0 it accepts multiple arity mappings expressed as pairs consisting of vectors of argument names and maps of default values for all or some of names.</p><p>The order of names in a vector is important. Each given name will become a key of named argument which value will be passed to the given function on the same position as in the vector.</p><p>If unquoted symbol is given in a vector or in a map, it will be transformed to a keyword of the same name. Use quoted symbols if you want to use symbols as keys of named arguments.</p><p>If the <code>&amp;rest</code> special symbol is placed in a vector then the passed value that corresponds to its position will be a map containing all named arguments that weren't handled. If there are none, <code>nil</code> value is passed.</p><p>The macro is capable of handling multiple arities. In such case the declared arity will be matched against the given named arguments by comparing its keys with keys in all declared mappings. First it will try to match them without considering default values (if any) and in case there is no success (there is no declared arity that can be satisfied by the given arguments) matching is preformed again with default arguments merged. From the resulting set of matching arity mappings the picked one is that with the least requirements (that has the lowest count of declared arguments).</p><p>The result is a function object.</p></div><section class="subsection" id="nameize-usage-ex"><h4 class="subsection">3.4.1  &nbsp;&nbsp; Usage examples</h4><div class="code"><a name="nameize-usage"></a><h5>e.3.22  &nbsp;-&nbsp; Usage of <code>nameize</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def nfun (nameize #(list %1 %2) [a b]))
(nfun :a 1 :b 2)
=&gt; '(1 2)

  
(def nfun (nameize (fn [&amp; a] a) [a b] {:a 7 :b 8}))
(nfun :b 2)
=&gt; '(7 2)

(defn fun [&amp; more] more)

(def nfun (nameize fun [a b c]))
(nfun :a 1 :b 2 :c 3 :d 4)
=&gt; '(1 2 3)

(def nfun (nameize fun [a b c &amp;rest]))
(nfun :a 1 :b 2 :c 3 :d 4)
=&gt; '(1 2 3 {:d 4})

(def nfun (nameize fun [a &amp;rest b c] {:a 1}))
(nfun :b 2 :c 3 :d 4)
=&gt; '(1 {:d 4} 2 3)

(def nfun (nameize fun [a b c &amp;rest]))
(nfun :a 1 :b 2 :c 3)
=&gt; '(1 2 3 nil)</div></div><div class="code"><a name="nameize-usage-multi"></a><h5>e.3.23  &nbsp;-&nbsp; Handling multiple arities by <code>nameize</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def nfun (nameize (fn [&amp; a] a)
                   [a]           {:a 5}
                   [a b]         {}
                   [a b &amp;rest]   {}
                   [a b c &amp;rest] {:a 1 :e 5}))

  
(nfun)                     =&gt; '(5)                   ; matched: [a]
(nfun :a 1)                =&gt; '(1)                   ; matched: [a]
(nfun :a 1 :b 2)           =&gt; '(1 2)                 ; matched: [a b]
(nfun :a 1 :b 2 :c 3)      =&gt; '(1 2 3 {:e 5})        ; matched: [a b c &amp;rest]
(nfun :a 1 :b 2 :c 3 :d 4) =&gt; '(1 2 3 {:d 4 :e 5})</div></div><div class="code"><a name="nameize-usage-notfun"></a><h5>e.3.24  &nbsp;-&nbsp; Handling invalid values by <code>nameize</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def notfun)
(nameize notfun []) =&gt; (throws java.lang.AssertionError)

  
(defn fun [a b] (list a b))
(def nfun (nameize fun [a b]))
(nfun :a 1)
=&gt; (throws java.lang.IllegalArgumentException)</div></div></section></section><section class="section" id="nameize*"><h3 class="section">3.5  &nbsp;&nbsp; nameize*</h3><div class="code"><a name="nameize*-synopsis"></a><div hljs="hljs" language="clojure" no-escape="no-escape">(futils.named/nameize* f names)
(futils.named/nameize* f names defaults)
(futils.named/nameize* f arity-mappings…)</div></div><div class="paragraph"><p>where <code>arity-mappings</code> is a pair expressed as: <code>names defaults</code>.</p></div><div class="paragraph"><p>Creates a wrapper that passes named arguments as positional arguments. Takes a funtion object (<code>f</code>), a collection (preferably a vector) containing expected names of arguments (<code>names</code>) expressed as keywords, symbols, strings or whatever suits you, and a map of default values for named arguments (<code>defaults</code>).</p><p>Since version 0.7.0 it accepts multiple arity mappings expressed as pairs consisting of vectors of argument names and maps of default values for all or some of names.</p><p>The order of names in a vector is important. Each given name will become a key of named argument which value will be passed to the given function on the same position as in the vector.</p><p>If unquoted symbol is given in a vector or in a map, it will be transformed to a keyword of the same name. Use quoted symbols if you want to use symbols as keys of named arguments.</p><p>If the <code>&amp;rest</code> special symbol is placed in <code>exp-args</code> vector then the passed value that corresponds to its position will be a map containing all named arguments that weren't handled. If there are none, nil value is passed.</p><p>The function is capable of handling multiple arities. In such case the declared arity will be matched against the given named arguments by comparing its keys with keys in all declared mappings. First it will try to match them without considering default values (if any) and in case there is no success (there is no declared arity that can be satisfied by the given arguments) matching is preformed again with default arguments merged. From the resulting set of matching arity mappings the picked one is that with the least requirements (that has the lowest count of declared arguments).</p><p>A function object is returned.</p></div><section class="subsection" id="nameize*-usage-ex"><h4 class="subsection">3.5.1  &nbsp;&nbsp; Usage examples</h4><div class="code"><a name="nameize*-usage"></a><h5>e.3.25  &nbsp;-&nbsp; Usage of <code>nameize*</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def nfun (nameize* #(list %1 %2) ['a :b] {}))
(nfun 'a 1 :b 2)
=&gt; '(1 2)


(def nfun (nameize* (fn [&amp; a] a) '[a b] '{a 7 b 8}))
(nfun 'b 2)
=&gt; '(7 2)

(defn fun [&amp; more] more)

(def nfun (nameize* fun '[a b c] {}))
(nfun 'a 1 'b 2 'c 3 'd 4)
=&gt; '(1 2 3)

(def nfun (nameize* fun [:a :b :c '&amp;rest] {}))
(nfun :a 1 :b 2 :c 3 :d 4)
=&gt; '(1 2 3 {:d 4})

(def nfun (nameize* fun [:a '&amp;rest :b :c] {:a 1}))
(nfun :b 2 :c 3 :d 4)
=&gt; '(1 {:d 4} 2 3)

(def nfun (nameize* fun '[:a :b :c &amp;rest] {}))
(nfun :a 1 :b 2 :c 3)
=&gt; '(1 2 3 nil)</div></div><div class="code"><a name="nameize*-usage-multi"></a><h5>e.3.26  &nbsp;-&nbsp; Handling multiple arities by <code>nameize*</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def nfun (nameize* (fn [&amp; a] a)
                    '[:a]             {:a 5}
                    '[:a :b]          {}
                    '[:a :b &amp;rest]    {}
                    '[:a :b :c &amp;rest] {:a 1 :e 5}))


(nfun)                     =&gt; '(5)                   ; matched: [a]
(nfun :a 1)                =&gt; '(1)                   ; matched: [a]
(nfun :a 1 :b 2)           =&gt; '(1 2)                 ; matched: [a b]
(nfun :a 1 :b 2 :c 3)      =&gt; '(1 2 3 {:e 5})        ; matched: [a b c &amp;rest]
(nfun :a 1 :b 2 :c 3 :d 4) =&gt; '(1 2 3 {:d 4 :e 5})</div></div><div class="code"><a name="nameize*-usage-notfun"></a><h5>e.3.27  &nbsp;-&nbsp; Handling invalid values by <code>nameize*</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def notfun)
(nameize* notfun [] {}) =&gt; (throws java.lang.AssertionError)


(defn fun [a b] (list a b))
(def nfun (nameize* fun [:a :b] {}))
(nfun :a 1)
=&gt; (throws java.lang.IllegalArgumentException)</div></div></section></section><section class="section" id="frepeat"><h3 class="section">3.6  &nbsp;&nbsp; frepeat</h3><div class="code"><a name="frepeat-synopsis"></a><div hljs="hljs" language="clojure" no-escape="no-escape">(futils.utils/frepeat n? f kvs?)</div></div><div class="paragraph"><p>Returns a lazy sequence of results produced by the given function <code>f</code> which should accept named arguments.</p><p>If the first argument passed to frepeat is a number (<code>n</code>) and the second is a function (<code>f</code>) it will limit the iterations to the specified count.</p><p>If the numeric argument is missing and only a function object is given the frepeat will produce infinite sequence of calls.</p><p>The last, optional argument should be a map (<code>kvs</code>) that initializes named arguments that will be passed to the first and subsequent calls to <code>f</code>.</p><p>Additionally each call to <code>f</code> will pass the following keyword arguments:</p><ul><li><code>:iteration</code> – a number of current iteration (starting from 1),</li><li><code>:previous</code> – a result of the previous call to <code>f</code>.</li></ul><p>The first call to <code>f</code> will pass the following:</p><ul><li><code>:iteration</code> – 1,</li><li><code>:iterations</code> – a total number of iterations (if <code>n</code> was given).</li></ul><p>It is possible to set the initial value of <code>:previous</code> if there is a need for that (by passing it to <code>frepeat</code>) or shadow the value assigned to <code>:iterations</code> after the first call (by setting it in the passed function <code>f</code>).</p><p>Values associated with <code>:iteration</code> and <code>:previous</code> keys will always change during each call.</p></div><section class="subsection" id="frepeat-usage-ex"><h4 class="subsection">3.6.1  &nbsp;&nbsp; Usage examples</h4><div class="code"><a name="frepeat-usage-basic"></a><h5>e.3.28  &nbsp;-&nbsp; Basic usage of <code>frepeat</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(take 5 (frepeat (constantly :x)))
=&gt; '(:x :x :x :x :x)
  
(frepeat 5 (constantly :x))
=&gt; '(:x :x :x :x :x)
  
(frepeat 5 (fn [&amp; {:keys [iteration]}] iteration))
=&gt; '(1 2 3 4 5)</div></div><div class="code"><a name="frepeat-usage"></a><h5>e.3.29  &nbsp;-&nbsp; Using <code>frepeat</code> on anonymous functions</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def repeater #(inc (:previous (apply array-map %&amp;))))
(def numbers (frepeat repeater {:previous 0}))
(take 5 numbers)
=&gt; '(1 2 3 4 5)
  
(frepeat 5 (fn [&amp; {:keys [previous]
                   :or {previous 9}}]
             (inc previous)))
=&gt; '(10 11 12 13 14)</div></div><div class="code"><a name="frepeat-usage-named"></a><h5>e.3.30  &nbsp;-&nbsp; Using <code>frepeat</code> on named functions</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn repeater
  [&amp; {:keys [previous iteration iterations a]}]
  [iteration iterations a])
  
(frepeat 5 repeater {:a :something})
=&gt; '([1 5 :something]
     [2 5 :something]
     [3 5 :something]
     [4 5 :something]
     [5 5 :something])</div></div><div class="code"><a name="frepeat-usage-notfun"></a><h5>e.3.31  &nbsp;-&nbsp; Handling invalid values by <code>frepeat</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def notfun)
  
(frepeat)        =&gt; (throws clojure.lang.ArityException)
(frepeat   1)    =&gt; (throws java.lang.ClassCastException)
(frepeat nil)    =&gt; (throws java.lang.NullPointerException)
(frepeat &quot;a&quot;)    =&gt; (throws java.lang.ClassCastException)
(frepeat notfun) =&gt; (throws java.lang.IllegalStateException)
(frepeat String) =&gt; (throws java.lang.ClassCastException)</div></div></section></section><section class="section" id="mapply"><h3 class="section">3.7  &nbsp;&nbsp; mapply</h3><div class="code"><a name="mapply-synopsis"></a><div hljs="hljs" language="clojure" no-escape="no-escape">(futils.utils/mapply f args* args-map)</div></div><div class="paragraph"><p>It works like <code>apply</code> but handles named arguments. Takes function <code>f</code>, an optional list of arguments (<code>args&#42;</code>) to be passed during a call to it and a map (<code>args-map</code>) that will be decomposed and passed as named arguments.</p><p>Returns the result of calling f.</p></div><section class="subsection" id="mapply-usage-ex"><h4 class="subsection">3.7.1  &nbsp;&nbsp; Usage examples</h4><div class="code"><a name="mapply-usage"></a><h5>e.3.32  &nbsp;-&nbsp; Usage of <code>mapply</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(mapply assoc {} {:a 1 :b 2 :c 3})
=&gt; {:a 1 :b 2 :c 3}


(defn fun [&amp; {:as args}] args)
(mapply fun {:a 1 :b 2 :c 3})
=&gt; {:a 1 :b 2 :c 3}

(defn fun [a b &amp; {:as args}] (sort (list* a b (vals args))))
(mapply fun 10 20 {:a 1 :b 2 :c 3})
=&gt; '(1 2 3 10 20)</div></div><div class="code"><a name="mapply-usage-notfun"></a><h5>e.3.33  &nbsp;-&nbsp; Handling invalid values by <code>mapply</code></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def notfun)


(mapply)        =&gt; (throws clojure.lang.ArityException)
(mapply      1) =&gt; (throws java.lang.ClassCastException)
(mapply    nil) =&gt; (throws java.lang.NullPointerException)
(mapply    &quot;a&quot;) =&gt; (throws java.lang.ClassCastException)
(mapply notfun) =&gt; (throws java.lang.IllegalStateException)
(mapply String) =&gt; (throws java.lang.ClassCastException)</div></div></section></section></section>
    </div>
</div><!--end of .container-->

</body>

<script>
  $('#nav').affix({
    offset: {
        top: $('#nav').offset().top,
        bottom: $('footer').outerHeight(true) + $('.application').outerHeight(true) + 40
    }});
</script>


<script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>
</body>
</html>
